// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>
// All rights reserved. Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

import 'package:logging/logging.dart';

import 'cross_vocabulary_resolver.dart';
import 'model/vocabulary_model.dart';

/// Logger for class generator operations
final _log = Logger('VocabularyClassGenerator');

/// Generator for creating Dart classes from vocabulary models.
///
/// This class is responsible for generating well-formatted Dart code
/// representing a vocabulary, with proper class structure, documentation,
/// and type safety.
class VocabularyClassGenerator {
  /// Optional cross-vocabulary resolver for handling properties across vocabulary boundaries
  final CrossVocabularyResolver? resolver;

  /// Creates a new vocabulary class generator.
  ///
  /// [resolver] Optional cross-vocabulary resolver for property inheritance across vocabularies
  const VocabularyClassGenerator({this.resolver});

  /// Generates Dart code for a vocabulary model.
  String generate(VocabularyModel model) {
    final buffer = StringBuffer();

    // Validate model has terms
    _validateModelHasTerms(model);

    // Add header and copyright
    _writeHeader(buffer);

    // Write library documentation and declaration first
    _writeLibraryDoc(buffer, model);

    // Import necessary packages (after library declaration)
    _writeImports(buffer);

    // Write primary class containing all terms
    _writePrimaryClass(buffer, model);

    // Write individual class for each RDF class
    _writeIndividualClasses(buffer, model);

    return buffer.toString();
  }

  /// Validates that the model contains at least some terms (classes, properties, datatypes, or other terms).
  /// Throws an exception if the model is empty.
  void _validateModelHasTerms(VocabularyModel model) {
    final hasTerms =
        model.classes.isNotEmpty ||
        model.properties.isNotEmpty ||
        model.datatypes.isNotEmpty ||
        model.otherTerms.isNotEmpty;

    if (!hasTerms) {
      throw StateError(
        'No terms found for vocabulary: ${model.name} (${model.namespace}). '
        'The vocabulary source may be inaccessible or incorrectly formatted.',
      );
    }
  }

  /// Writes the file header with copyright information.
  void _writeHeader(StringBuffer buffer) {
    buffer.writeln('// Copyright (c) 2025, Klas Kalaß <habbatical@gmail.com>');
    buffer.writeln(
      '// All rights reserved. Use of this source code is governed by a BSD-style',
    );
    buffer.writeln('// license that can be found in the LICENSE file.');
    buffer.writeln();
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by VocabularyBuilder');
    buffer.writeln();
  }

  /// Writes the required imports for the generated file.
  void _writeImports(StringBuffer buffer) {
    buffer.writeln("import 'package:rdf_core/src/graph/rdf_term.dart';");
    buffer.writeln();
  }

  /// Writes the library documentation.
  void _writeLibraryDoc(StringBuffer buffer, VocabularyModel model) {
    final name = _capitalize(model.name);

    buffer.writeln('/// $name Vocabulary');
    buffer.writeln('///');
    buffer.writeln(
      '/// Provides constants for the ${name.toUpperCase()} vocabulary',
    );
    buffer.writeln('/// (${model.namespace}).');
    buffer.writeln('///');
    buffer.writeln('/// Example usage:');
    buffer.writeln('/// ```dart');
    buffer.writeln('/// import \'package:rdf_core/vocab.dart\';');

    if (model.properties.isNotEmpty) {
      final exampleProp = _dartIdentifier(model.properties.first.localName);
      buffer.writeln(
        '/// final property = ${name}.$exampleProp; // Access property directly from main class',
      );
    }

    if (model.classes.isNotEmpty) {
      final exampleClass = _dartIdentifier(model.classes.first.localName);
      buffer.writeln(
        '/// final classIri = ${name}$exampleClass.classIri; // Access class IRI',
      );

      if (model.properties.isNotEmpty) {
        final exampleProp = _dartIdentifier(model.properties.first.localName);
        buffer.writeln(
          '/// final property = ${name}$exampleClass.$exampleProp; // Access property from class',
        );
      }
    }

    buffer.writeln('/// ```');
    buffer.writeln('///');
    buffer.writeln(
      '/// All constants are pre-constructed as IriTerm objects to enable direct use in',
    );
    buffer.writeln(
      '/// constructing RDF graphs without repeated string concatenation or term creation.',
    );
    buffer.writeln('///');
    buffer.writeln('/// [Vocabulary Reference](${model.namespace})');
    buffer.writeln('library ${model.prefix}_vocab;');
    buffer.writeln();
  }

  /// Writes the primary vocabulary class that contains all terms.
  void _writePrimaryClass(StringBuffer buffer, VocabularyModel model) {
    final className = _capitalize(model.name);

    buffer.writeln(
      '/// Main ${className} vocabulary class containing all terms',
    );
    buffer.writeln('///');
    buffer.writeln(
      '/// Contains all terms defined in the ${model.namespace} vocabulary.',
    );
    buffer.writeln('class $className {');
    buffer.writeln('  // Private constructor prevents instantiation');
    buffer.writeln('  const ${className}._();');
    buffer.writeln();
    buffer.writeln('  /// Base IRI for ${className} vocabulary');
    buffer.writeln('  /// [Spec](${model.namespace})');
    buffer.writeln("  static const String namespace = '${model.namespace}';");
    buffer.writeln("  static const String prefix = '${model.prefix}';");
    buffer.writeln();

    // Add all terms
    for (final term in [
      ...model.classes,
      ...model.datatypes,
      ...model.otherTerms,
    ]) {
      _writeTerm(buffer, term, className);
    }

    // Add predicates
    for (final property in model.properties) {
      _writeTerm(buffer, property, className);
    }

    buffer.writeln('}');
    buffer.writeln();
  }

  /// Writes a class for each RDF class in the vocabulary.
  void _writeIndividualClasses(StringBuffer buffer, VocabularyModel model) {
    if (model.classes.isEmpty) return;

    final className = _capitalize(model.name);

    // Build class hierarchy for property inheritance
    final classHierarchy = _buildClassHierarchy(model);

    // Map of property IRIs to property objects
    final propertyMap = {for (final prop in model.properties) prop.iri: prop};

    // Generate a class for each RDF class
    for (final rdfClass in model.classes) {
      final dartClassName = '$className${_dartIdentifier(rdfClass.localName)}';

      buffer.writeln(
        '/// ${rdfClass.localName} class from ${className} vocabulary',
      );
      buffer.writeln('///');

      if (rdfClass.comment != null) {
        final formattedComment = _formatMultilineComment(rdfClass.comment!);
        buffer.writeln('/// $formattedComment');
        buffer.writeln('///');
      }

      buffer.writeln(
        '/// This class provides access to all properties that can be used with ${rdfClass.localName}.',
      );
      buffer.writeln('/// [Class Reference](${rdfClass.iri})');

      // Add seeAlso references if available
      if (rdfClass.seeAlso.isNotEmpty) {
        for (final seeAlso in rdfClass.seeAlso) {
          buffer.writeln('/// [See also]($seeAlso)');
        }
      }

      buffer.writeln('class $dartClassName {');
      buffer.writeln('  // Private constructor prevents instantiation');
      buffer.writeln('  const ${dartClassName}._();');
      buffer.writeln();

      // Add the classIri field for the class itself
      buffer.writeln('  /// IRI term for the ${rdfClass.localName} class');
      buffer.writeln(
        '  /// Use this to specify that a resource is of this type.',
      );
      buffer.writeln(
        "  static const classIri = IriTerm.prevalidated('${rdfClass.iri}');",
      );
      buffer.writeln();

      // Get all properties that can be used with this class
      final properties = _getPropertiesForClass(
        rdfClass.iri,
        model.namespace,
        classHierarchy,
        propertyMap,
      );

      // Write all applicable properties
      for (final property in properties) {
        _writeTerm(
          buffer,
          property,
          className,
          prefix: '  ',
          classNamespace: model.namespace,
        );
      }

      buffer.writeln('}');
      buffer.writeln();
    }
  }

  /// Writes a single term as a static constant.
  void _writeTerm(
    StringBuffer buffer,
    VocabularyTerm term,
    String className, {
    String prefix = '',
    String? classNamespace,
  }) {
    final dartName = _getPropertyName(term, classNamespace);

    // Write documentation
    buffer.writeln(
      '$prefix/// IRI for ${className.toLowerCase()}:${term.localName}',
    );

    if (term.comment != null) {
      // Format the comment for Dart documentation
      final formattedComment = _formatMultilineComment(term.comment!);
      buffer.writeln('$prefix///');
      buffer.writeln('$prefix/// $formattedComment');
    }

    // Add domain and range information for properties in a more developer-friendly way
    if (term is VocabularyProperty) {
      buffer.writeln('$prefix///');

      if (term.domains.isNotEmpty) {
        buffer.writeln('$prefix/// Can be used on: ${term.domains.join(', ')}');
      }

      if (term.ranges.isNotEmpty) {
        buffer.writeln(
          '$prefix/// Expects values of type: ${term.ranges.join(', ')}',
        );
      }
    }

    // Add seeAlso references if available
    if (term.seeAlso.isNotEmpty) {
      buffer.writeln('$prefix///');
      for (final seeAlso in term.seeAlso) {
        buffer.writeln('$prefix/// [See also]($seeAlso)');
      }
    }

    buffer.writeln('$prefix///');

    // Write the constant declaration with correct indentation
    buffer.writeln(
      "$prefix" +
          "static const $dartName = IriTerm.prevalidated('${term.iri}');",
    );
    buffer.writeln();
  }

  /// Formats a multiline comment for Dart documentation
  String _formatMultilineComment(String comment) {
    return comment
        .split('\n')
        .map((line) => line.trim())
        .where((line) => line.isNotEmpty)
        .join('\n  /// ');
  }

  /// Gets a property name with prefix if it comes from a different namespace
  String _getPropertyName(VocabularyTerm term, String? classNamespace) {
    final dartName = _dartIdentifier(term.localName);

    // If classNamespace is null, we're generating the main class (no prefix needed)
    if (classNamespace == null) return dartName;

    // If the property belongs to a different namespace than the class,
    // prefix it to avoid naming conflicts
    if (!term.iri.startsWith(classNamespace)) {
      // Extract the namespace from the IRI
      final namespace = _extractNamespace(term.iri);
      if (namespace != null && namespace != classNamespace) {
        final foreignVocabPrefix = _getNamespacePrefix(namespace);
        if (foreignVocabPrefix != null) {
          // Combine prefix with camelCased name
          return '$foreignVocabPrefix${_capitalize(dartName)}';
        }
      }
    }

    return dartName;
  }

  /// Extracts the namespace part from an IRI
  String? _extractNamespace(String iri) {
    // Try to find the namespace by common delimiters
    final hashIndex = iri.lastIndexOf('#');
    if (hashIndex != -1) {
      return iri.substring(0, hashIndex + 1);
    }

    final slashIndex = iri.lastIndexOf('/');
    if (slashIndex != -1) {
      return iri.substring(0, slashIndex + 1);
    }

    return null;
  }

  /// Gets a prefix for a namespace
  String? _getNamespacePrefix(String namespace) {
    // Common namespace to prefix mappings
    final prefixMap = {
      'http://www.w3.org/1999/02/22-rdf-syntax-ns#': 'rdf',
      'http://www.w3.org/2000/01/rdf-schema#': 'rdfs',
      'http://www.w3.org/2001/XMLSchema#': 'xsd',
      'http://www.w3.org/2002/07/owl#': 'owl',
      'http://purl.org/dc/elements/1.1/': 'dc',
      'http://purl.org/dc/terms/': 'dcterms',
      'http://xmlns.com/foaf/0.1/': 'foaf',
      'http://www.w3.org/2004/02/skos/core#': 'skos',
      'http://www.w3.org/2006/vcard/ns#': 'vcard',
      'http://www.w3.org/ns/auth/acl#': 'acl',
      'http://www.w3.org/ns/ldp#': 'ldp',
      'http://schema.org/': 'schema',
      'http://www.w3.org/ns/solid/terms#': 'solid',
    };

    return prefixMap[namespace];
  }

  /// Builds a map of class IRI to list of all parent class IRIs (including inherited)
  Map<String, Set<String>> _buildClassHierarchy(VocabularyModel model) {
    final hierarchy = <String, Set<String>>{};

    // Initialize with direct parent classes
    for (final rdfClass in model.classes) {
      hierarchy[rdfClass.iri] = Set.from(rdfClass.superClasses);
    }

    // Resolve full inheritance (transitive closure)
    bool changed;
    do {
      changed = false;

      for (final entry in hierarchy.entries) {
        final classIri = entry.key;
        final parents = Set<String>.from(entry.value);

        for (final parentIri in parents.toList()) {
          // Add parent's parents
          if (hierarchy.containsKey(parentIri)) {
            final grandparents = hierarchy[parentIri]!;
            final sizeBefore = parents.length;
            parents.addAll(grandparents);
            if (parents.length > sizeBefore) {
              changed = true;
              hierarchy[classIri] = parents;
            }
          }
        }
      }
    } while (changed);

    return hierarchy;
  }

  /// Gets all properties applicable to a given class including inherited properties
  List<VocabularyProperty> _getPropertiesForClass(
    String classIri,
    String vocabNamespace,
    Map<String, Set<String>> classHierarchy,
    Map<String, VocabularyProperty> propertyMap,
  ) {
    // If a cross-vocabulary resolver is available, use it
    if (resolver != null) {
      _log.fine('Using cross-vocabulary resolver for class $classIri');
      return resolver!.getPropertiesForClass(classIri, vocabNamespace);
    }

    // Otherwise fall back to the original implementation (local vocabulary only)
    _log.fine('Using local property resolution for class $classIri');

    final result = <VocabularyProperty>[];
    final allParentClasses = {classIri, ...(classHierarchy[classIri] ?? {})};

    for (final property in propertyMap.values) {
      // If property has no domains, it can be used with any class
      if (property.domains.isEmpty) {
        result.add(property);
        continue;
      }

      // Check if any domain of the property is compatible with this class
      for (final domain in property.domains) {
        if (allParentClasses.contains(domain)) {
          result.add(property);
          break;
        }
      }
    }

    return result;
  }

  /// Converts a local name to a valid Dart identifier.
  String _dartIdentifier(String localName) {
    // Special case handling for names that would result in invalid Dart identifiers
    if (localName.startsWith('_')) {
      return 'underscore${localName.substring(1)}';
    }

    if (localName.startsWith(RegExp(r'\d'))) {
      return 'n$localName';
    }

    // Replace characters that are not valid in Dart identifiers
    return localName.replaceAll(RegExp(r'[^a-zA-Z0-9_]'), '_');
  }

  /// Capitalizes the first letter of a string.
  String _capitalize(String s) {
    if (s.isEmpty) return s;
    return s[0].toUpperCase() + s.substring(1);
  }
}
